import requests
from urllib.parse import urlparse, parse_qs
import re
from typing import List, Dict, Optional
import logging
import random
from pathlib import Path

class SSTIScanner:
    def __init__(self, target_url: str, cookies: Optional[Dict] = None, headers: Optional[Dict] = None):
        self.target_url = target_url
        self.cookies = cookies or {}
        self.headers = headers or {}
        self.vulnerable_params = []
        self.payloads = self.load_payloads()

    def load_payloads(self) -> List[str]:
        payloads = set()
        # Load from ssti-payloads repo
        ssti_path = Path('external_tools/ssti-payloads')
        if ssti_path.exists():
            for file in ssti_path.glob('*.txt'):
                with open(file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            payloads.add(line)
        # Load from PayloadsAllTheThings
        pat_path = Path('external_tools/PayloadsAllTheThings/Server Side Template Injection')
        if pat_path.exists():
            for file in pat_path.glob('*.md'):
                with open(file, 'r', encoding='utf-8', errors='ignore') as f:
                    for line in f:
                        if any(x in line for x in ['{{', '${', '{%']):
                            payloads.add(line.strip())
        # Add randomized marker payloads
        rand1 = random.randint(10000, 99999)
        rand2 = random.randint(10000, 99999)
        payloads.add(f'{{{{{rand1}*{rand2}}}}}')
        payloads.add(f'${{{rand1}*{rand2}}}')
        return list(payloads)

    def get_params(self) -> List[str]:
        # Extract GET params from URL
        parsed = urlparse(self.target_url)
        params = list(parse_qs(parsed.query).keys())
        # Try to find form params from the page
        try:
            resp = requests.get(self.target_url, cookies=self.cookies, headers=self.headers, timeout=10)
            form_params = re.findall(r'name=["\']([^"\']+)["\']', resp.text)
            params = list(set(params + form_params))
        except Exception as e:
            logging.error(f"Error fetching form params: {e}")
        return params

    def is_reflected(self, param: str, method: str = 'GET') -> bool:
        marker = 'ssti_reflect_test_12345'
        try:
            if method == 'GET':
                resp = requests.get(self.target_url, params={param: marker}, cookies=self.cookies, headers=self.headers, timeout=10)
            else:
                resp = requests.post(self.target_url, data={param: marker}, cookies=self.cookies, headers=self.headers, timeout=10)
            return marker in resp.text
        except Exception as e:
            logging.error(f"Reflection check failed for {param} ({method}): {e}")
            return False

    def scan_parameter(self, param_name: str, method: str = 'GET') -> List[str]:
        """
        Scan a specific parameter for SSTI vulnerabilities using GET or POST
        """
        detected = []
        for payload in self.payloads:
            expected = self._expected_result(payload)
            try:
                if method == 'GET':
                    resp = requests.get(self.target_url, params={param_name: payload}, cookies=self.cookies, headers=self.headers, timeout=10)
                else:
                    resp = requests.post(self.target_url, data={param_name: payload}, cookies=self.cookies, headers=self.headers, timeout=10)
                if expected and expected in resp.text:
                    detected.append(f'{method}:{param_name} ({payload})')
                # Also check if payload itself is reflected (for basic detection)
                elif payload in resp.text:
                    detected.append(f'{method}:{param_name} (payload reflected)')
            except Exception as e:
                logging.error(f"Error testing payload on parameter {param_name} ({method}): {str(e)}")
                continue
        return detected

    def _expected_result(self, payload: str) -> Optional[str]:
        # Try to extract expected result for math payloads like {{7*7}}
        m = re.match(r'\{\{(\d+)\*(\d+)\}\}', payload)
        if m:
            return str(int(m.group(1)) * int(m.group(2)))
        m = re.match(r'\$\{(\d+)\*(\d+)\}', payload)
        if m:
            return str(int(m.group(1)) * int(m.group(2)))
        return None

    def scan_url(self) -> Dict[str, List[str]]:
        """
        Scan the target URL for SSTI vulnerabilities (GET/POST params)
        """
        results = {}
        params = self.get_params()
        for param in params:
            # Check GET
            if self.is_reflected(param, 'GET'):
                detected = self.scan_parameter(param, 'GET')
                if detected:
                    results[f'GET:{param}'] = detected
            # Check POST
            if self.is_reflected(param, 'POST'):
                detected = self.scan_parameter(param, 'POST')
                if detected:
                    results[f'POST:{param}'] = detected
        return results

    def generate_report(self, results: Dict[str, List[str]]) -> str:
        if not results:
            return "No SSTI vulnerabilities found."
        report = "SSTI Vulnerability Report:\n"
        report += "=" * 50 + "\n\n"
        for param, findings in results.items():
            report += f"Parameter: {param}\n"
            for finding in findings:
                report += f"  - {finding}\n"
            report += "-" * 30 + "\n"
        return report 