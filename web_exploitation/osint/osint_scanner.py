import requests
import whois
import dns.resolver
import shodan
import socket
import re
import json
from typing import Dict, List, Optional
from pathlib import Path
import logging
from bs4 import BeautifulSoup
import time
from datetime import datetime
import os
import subprocess
from urllib.parse import urlparse, urljoin
from .github_dorker import GitHubDorker
import ssl
import ipaddress

class OSINTScanner:
    def __init__(self, target: str, shodan_api_key: Optional[str] = None):
        self.target = target
        self.shodan_api_key = shodan_api_key
        self.logger = logging.getLogger(__name__)
        
        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )

    def whois_lookup(self) -> Dict:
        """Perform WHOIS lookup on the target domain"""
        try:
            w = whois.whois(self.target)
            return {
                'registrar': w.registrar,
                'creation_date': w.creation_date,
                'expiration_date': w.expiration_date,
                'name_servers': w.name_servers,
                'status': w.status,
                'registrant': w.registrant,
                'admin': w.admin,
                'tech': w.tech,
                'dnssec': w.dnssec
            }
        except Exception as e:
            self.logger.error(f"WHOIS lookup error: {e}")
            return {'error': str(e)}

    def dns_enumeration(self) -> Dict:
        """Perform DNS enumeration on the target domain"""
        results = {}
        record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'SOA', 'CNAME', 'PTR', 'SRV']
        
        for record_type in record_types:
            try:
                answers = dns.resolver.resolve(self.target, record_type)
                results[record_type] = [str(rdata) for rdata in answers]
            except Exception as e:
                self.logger.error(f"DNS {record_type} lookup error: {e}")
                results[record_type] = f"Error: {str(e)}"
        
        # Add reverse DNS lookup for IP addresses
        try:
            ip_addresses = results.get('A', []) + results.get('AAAA', [])
            reverse_dns = {}
            for ip in ip_addresses:
                try:
                    reverse = socket.gethostbyaddr(ip)
                    reverse_dns[ip] = reverse[0]
                except:
                    reverse_dns[ip] = "No reverse DNS"
            results['Reverse DNS'] = reverse_dns
        except Exception as e:
            self.logger.error(f"Reverse DNS lookup error: {e}")
            results['Reverse DNS'] = {'error': str(e)}
        
        return results

    def wayback_machine(self) -> Dict:
        """Get historical data from Wayback Machine"""
        try:
            url = f"https://web.archive.org/cdx/search/cdx?url={self.target}&output=json"
            response = requests.get(url)
            if response.status_code == 200:
                data = response.json()
                if len(data) > 1:  # First row is headers
                    return {
                        'total_snapshots': len(data) - 1,
                        'first_snapshot': data[1][1] if len(data) > 1 else None,
                        'last_snapshot': data[-1][1] if len(data) > 1 else None,
                        'snapshots': [
                            {
                                'timestamp': row[1],
                                'original': row[2],
                                'mimetype': row[3],
                                'statuscode': row[4],
                                'digest': row[5],
                                'length': row[6]
                            }
                            for row in data[1:6]  # Get first 5 snapshots
                        ]
                    }
            return {'error': 'No data found'}
        except Exception as e:
            self.logger.error(f"Wayback Machine error: {e}")
            return {'error': str(e)}

    def security_headers(self) -> Dict:
        """Check security headers of the target website"""
        try:
            url = f"https://{self.target}" if not self.target.startswith(('http://', 'https://')) else self.target
            response = requests.get(url)
            headers = response.headers
            
            security_headers = {
                'Strict-Transport-Security': {
                    'value': headers.get('Strict-Transport-Security', 'Not Set'),
                    'status': 'Good' if 'Strict-Transport-Security' in headers else 'Missing'
                },
                'X-Frame-Options': {
                    'value': headers.get('X-Frame-Options', 'Not Set'),
                    'status': 'Good' if 'X-Frame-Options' in headers else 'Missing'
                },
                'X-Content-Type-Options': {
                    'value': headers.get('X-Content-Type-Options', 'Not Set'),
                    'status': 'Good' if 'X-Content-Type-Options' in headers else 'Missing'
                },
                'X-XSS-Protection': {
                    'value': headers.get('X-XSS-Protection', 'Not Set'),
                    'status': 'Good' if 'X-XSS-Protection' in headers else 'Missing'
                },
                'Content-Security-Policy': {
                    'value': headers.get('Content-Security-Policy', 'Not Set'),
                    'status': 'Good' if 'Content-Security-Policy' in headers else 'Missing'
                },
                'Referrer-Policy': {
                    'value': headers.get('Referrer-Policy', 'Not Set'),
                    'status': 'Good' if 'Referrer-Policy' in headers else 'Missing'
                },
                'Permissions-Policy': {
                    'value': headers.get('Permissions-Policy', 'Not Set'),
                    'status': 'Good' if 'Permissions-Policy' in headers else 'Missing'
                },
                'Server': {
                    'value': headers.get('Server', 'Not Set'),
                    'status': 'Info'
                }
            }
            
            return security_headers
        except Exception as e:
            self.logger.error(f"Security headers check error: {e}")
            return {'error': str(e)}

    def ssl_info(self) -> Dict:
        """Get SSL certificate information"""
        try:
            hostname = self.target.replace('https://', '').replace('http://', '').split('/')[0]
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Calculate certificate validity period
                    not_before = datetime.strptime(cert['notBefore'], '%b %d %H:%M:%S %Y %Z')
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_remaining = (not_after - datetime.now()).days
                    
                    return {
                        'subject': dict(x[0] for x in cert['subject']),
                        'issuer': dict(x[0] for x in cert['issuer']),
                        'version': cert['version'],
                        'notBefore': cert['notBefore'],
                        'notAfter': cert['notAfter'],
                        'serialNumber': cert['serialNumber'],
                        'days_remaining': days_remaining,
                        'status': 'Valid' if days_remaining > 0 else 'Expired'
                    }
        except Exception as e:
            self.logger.error(f"SSL info error: {e}")
            return {'error': str(e)}

    def port_scan(self) -> Dict:
        """Perform basic port scan on common ports"""
        common_ports = [21, 22, 23, 25, 53, 80, 443, 445, 3306, 3389, 8080, 8443]
        results = {}
        
        try:
            hostname = self.target.replace('https://', '').replace('http://', '').split('/')[0]
            for port in common_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((hostname, port))
                    if result == 0:
                        service = socket.getservbyport(port)
                        results[port] = {
                            'status': 'open',
                            'service': service
                        }
                    sock.close()
                except:
                    continue
            return results
        except Exception as e:
            self.logger.error(f"Port scan error: {e}")
            return {'error': str(e)}

    def subdomain_enumeration(self) -> Dict:
        """Perform basic subdomain enumeration"""
        try:
            subdomains = set()
            
            # Try DNS enumeration
            try:
                answers = dns.resolver.resolve(self.target, 'NS')
                for rdata in answers:
                    subdomains.add(str(rdata))
            except:
                pass
            
            # Try common subdomains
            common_subdomains = ['www', 'mail', 'ftp', 'smtp', 'pop', 'admin', 'blog', 'dev', 'test', 'stage']
            for sub in common_subdomains:
                try:
                    full_domain = f"{sub}.{self.target}"
                    socket.gethostbyname(full_domain)
                    subdomains.add(full_domain)
                except:
                    continue
            
            return {
                'subdomains': list(subdomains),
                'total_found': len(subdomains)
            }
        except Exception as e:
            self.logger.error(f"Subdomain enumeration error: {e}")
            return {'error': str(e)}

    def web_server_info(self) -> Dict:
        """Retrieve web server type and version details"""
        try:
            url = f"https://{self.target}" if not self.target.startswith(('http://', 'https://')) else self.target
            response = requests.head(url, allow_redirects=True, timeout=5)
            server_header = response.headers.get('Server', 'Not disclosed')
            
            return {
                'server_header': server_header,
                'status': 'Found' if server_header != 'Not disclosed' else 'Not Disclosed'
            }
        except requests.exceptions.Timeout:
            self.logger.error(f"Web server info timeout for {self.target}")
            return {'error': 'Request timed out'}
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Web server info error for {self.target}: {e}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"An unexpected error occurred in web_server_info: {e}")
            return {'error': str(e)}

    def technology_detection(self) -> Dict:
        """Detect web technologies based on headers and common patterns."""
        technologies = set()
        try:
            url = f"https://{self.target}" if not self.target.startswith(('http://', 'https://')) else self.target
            response = requests.get(url, timeout=5)
            headers = response.headers
            content = response.text

            # Check common headers
            if 'X-Powered-By' in headers:
                technologies.add(f"X-Powered-By: {headers['X-Powered-By']}")
            if 'Server' in headers:
                technologies.add(f"Server: {headers['Server']}")
            if 'Set-Cookie' in headers:
                if re.search(r'wordpress', headers['Set-Cookie'], re.IGNORECASE):
                    technologies.add("WordPress (via Cookie)")
                if re.search(r'PHPSESSID', headers['Set-Cookie'], re.IGNORECASE):
                    technologies.add("PHP (via PHPSESSID)")
            
            # Check for common CMS/Frameworks in content (simplified)
            if re.search(r'wp-content', content, re.IGNORECASE) or re.search(r'wordpress', content, re.IGNORECASE):
                technologies.add("WordPress")
            if re.search(r'joomla', content, re.IGNORECASE):
                technologies.add("Joomla!")
            if re.search(r'drupal', content, re.IGNORECASE):
                technologies.add("Drupal")
            if re.search(r'<html[^>]*lang="en"[^>]*>', content, re.IGNORECASE):
                technologies.add("HTML5")
            if re.search(r'<script[^>]*src=[\'\"](.*?jquery.*?)[\'\"]', content, re.IGNORECASE):
                technologies.add("jQuery")
            if re.search(r'<script[^>]*src=[\'\"](.*?bootstrap.*?)[\'\"]', content, re.IGNORECASE):
                technologies.add("Bootstrap")
            
            return {'technologies': list(technologies) if technologies else ['None detected']}
        except requests.exceptions.Timeout:
            self.logger.error(f"Technology detection timeout for {self.target}")
            return {'error': 'Request timed out'}
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Technology detection error for {self.target}: {e}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"An unexpected error occurred in technology_detection: {e}")
            return {'error': str(e)}

    def email_enumeration(self) -> Dict:
        """Attempt to find email addresses related to the target domain."""
        emails = set()
        try:
            # Search website for emails
            url = f"https://{self.target}" if not self.target.startswith(('http://', 'https://')) else self.target
            response = requests.get(url, timeout=5)
            email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
            found_emails = re.findall(email_pattern, response.text)
            for email in found_emails:
                if self.target in email:
                    emails.add(email)
            
            # Add common permutations (example)
            common_names = ['admin', 'info', 'support', 'contact']
            for name in common_names:
                emails.add(f"{name}@{self.target}")
            
            return {'emails': list(emails) if emails else ['None detected']}
        except requests.exceptions.Timeout:
            self.logger.error(f"Email enumeration timeout for {self.target}")
            return {'error': 'Request timed out'}
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Email enumeration error for {self.target}: {e}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"An unexpected error occurred in email_enumeration: {e}")
            return {'error': str(e)}

    def run_all_scans(self) -> Dict:
        """Run all OSINT scans and return combined results"""
        results = {
            'target': self.target,
            'timestamp': datetime.now().isoformat(),
            'whois': self.whois_lookup(),
            'dns': self.dns_enumeration(),
            'wayback_machine': self.wayback_machine(),
            'security_headers': self.security_headers(),
            'ssl_info': self.ssl_info(),
            'port_scan': self.port_scan(),
            'subdomains': self.subdomain_enumeration(),
            'web_server_info': self.web_server_info(),
            'technology_detection': self.technology_detection(),
            'email_enumeration': self.email_enumeration()
        }
        
        return results

    def generate_report(self) -> str:
        """Generate a human-readable report of the OSINT results"""
        results = self.run_all_scans()
        
        report = f"OSINT Report for {self.target}\n"
        report += "=" * 50 + "\n"
        report += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        
        # WHOIS Information
        report += "WHOIS Information:\n"
        report += "-" * 20 + "\n"
        whois_data = results['whois']
        if 'error' not in whois_data:
            for key, value in whois_data.items():
                if value:
                    report += f"{key}: {value}\n"
        else:
            report += f"Error: {whois_data['error']}\n"
        report += "\n"
        
        # DNS Information
        report += "DNS Information:\n"
        report += "-" * 20 + "\n"
        for record_type, records in results['dns'].items():
            if isinstance(records, list):
                report += f"{record_type} Records:\n"
                for record in records:
                    report += f"  - {record}\n"
            elif isinstance(records, dict):
                report += f"{record_type}:\n"
                for key, value in records.items():
                    report += f"  - {key}: {value}\n"
            else:
                report += f"{record_type}: {records}\n"
        report += "\n"
        
        # Subdomain Information
        report += "Subdomain Information:\n"
        report += "-" * 20 + "\n"
        subdomain_data = results['subdomains']
        if 'error' not in subdomain_data:
            report += f"Total Subdomains Found: {subdomain_data['total_found']}\n"
            for subdomain in subdomain_data['subdomains']:
                report += f"  - {subdomain}\n"
        else:
            report += f"Error: {subdomain_data['error']}\n"
        report += "\n"
        
        # Port Scan Results
        report += "Port Scan Results:\n"
        report += "-" * 20 + "\n"
        port_data = results['port_scan']
        if 'error' not in port_data:
            if port_data:
                for port, info in port_data.items():
                    report += f"Port {port} ({info['service']}): {info['status']}\n"
            else:
                report += "No open ports found\n"
        else:
            report += f"Error: {port_data['error']}\n"
        report += "\n"
        
        # Web Server Information
        report += "Web Server Information:\n"
        report += "-" * 20 + "\n"
        web_server_data = results['web_server_info']
        if 'error' not in web_server_data:
            report += f"Server Header: {web_server_data['server_header']}\n"
            report += f"Status: {web_server_data['status']}\n"
        else:
            report += f"Error: {web_server_data['error']}\n"
        report += "\n"
        
        # Technology Detection
        report += "Technology Detection:\n"
        report += "-" * 20 + "\n"
        tech_data = results['technology_detection']
        if 'error' not in tech_data:
            if tech_data['technologies']:
                for tech in tech_data['technologies']:
                    report += f"- {tech}\n"
            else:
                report += "No technologies detected.\n"
        else:
            report += f"Error: {tech_data['error']}\n"
        report += "\n"

        # Email Enumeration
        report += "Email Enumeration:\n"
        report += "-" * 20 + "\n"
        email_data = results['email_enumeration']
        if 'error' not in email_data:
            if email_data['emails']:
                for email in email_data['emails']:
                    report += f"- {email}\n"
            else:
                report += "No emails found.\n"
        else:
            report += f"Error: {email_data['error']}\n"
        report += "\n"

        # Wayback Machine
        report += "Wayback Machine Data:\n"
        report += "-" * 20 + "\n"
        wayback_data = results['wayback_machine']
        if 'error' not in wayback_data:
            for key, value in wayback_data.items():
                if key != 'snapshots':
                    report += f"{key}: {value}\n"
            if 'snapshots' in wayback_data:
                report += "\nRecent Snapshots:\n"
                for snapshot in wayback_data['snapshots']:
                    report += f"  - {snapshot['timestamp']}: {snapshot['original']} ({snapshot['mimetype']})\n"
        else:
            report += f"Error: {wayback_data['error']}\n"
        report += "\n"
        
        # Security Headers
        report += "Security Headers:\n"
        report += "-" * 20 + "\n"
        headers_data = results['security_headers']
        if 'error' not in headers_data:
            for header, info in headers_data.items():
                report += f"{header}:\n"
                report += f"  Status: {info['status']}\n"
                report += f"  Value: {info['value']}\n"
        else:
            report += f"Error: {headers_data['error']}\n"
        report += "\n"
        
        # SSL Information
        report += "SSL Certificate Information:\n"
        report += "-" * 20 + "\n"
        ssl_data = results['ssl_info']
        if 'error' not in ssl_data:
            for key, value in ssl_data.items():
                if key == 'status':
                    report += f"Certificate Status: {value}\n"
                elif key == 'days_remaining':
                    report += f"Days Remaining: {value}\n"
                else:
                    report += f"{key}: {value}\n"
        else:
            report += f"Error: {ssl_data['error']}\n"
        
        return report 